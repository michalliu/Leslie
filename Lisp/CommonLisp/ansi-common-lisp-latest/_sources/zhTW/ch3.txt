.. highlight:: cl
   :linenothreshold: 0

第三章：列表
**********************************

列表是 Lisp 中基本的資料結構之一。在最早的 Lisp 方言中，他們是唯一的資料結構： Lisp 這個名字本來代表的是 "LISt Processor" 。但 Lisp 已經超越這個縮寫很久了。 Common Lisp 是一個有著各式各樣資料結構的通用型程式語言 (general-purpose programming language)。

Lisp 程式開發通常呼應著開發 Lisp 語言自身。在最初版本的 Lisp 程式，你可能使用很多列表。然而之後的版本，你可能切換到快速、特定的資料結構。本章描述了你可以用列表所做的很多事情，以及使用它們來演示一些普遍的 Lisp 概念。

3.1 創建 (Conses)
====================

在2.4節我們介紹了 ``cons`` , ``car`` , 以及 ``cdr`` ，基本的 List 操作函數 (list-manipulation fuctions)。 ``cons`` 真正所做的事情是，把兩個物件結合成一個有兩部分的物件，稱之為 *Cons* 物件。概念上來說，一個 Cons 物件是一對指標; 第一個是 car ，第二個是 cdr。

Cons 物件提供了一個方便的表示法來表示任何型態的物件。一個 Cons 物件裡的一對指標可以指向任何種類的物件，包括 Cons 物件本身。它利用到我們之後可以用 ``cons`` 來創建列表的可能性。

我們往往不會把列表想成是成對的，但它們可以這樣被定義。任何非空的列表，都可以被視為一對由列表第一個元素及列表其餘元素所組成的列表。 Lisp 列表體現了這個概念。我們使用 Cons 的一半 (car)來指向列表的第一個元素，然後用另一半 (cdr)指向列表其餘的元素 (可能是別的 Cons 物件或 nil)。 Lisp 的慣例是使用 ``car`` 代表列表的第一個元素，而用 ``cdr`` 代表列表的其餘的元素。所以現在 ``car`` 是列表的第一個元素的同義詞，而 ``cdr`` 是列表的其餘的元素的同義詞。列表不是不同的物件，而是像 Cons 這樣的方式連結起來。

當我們想在 ``NIL`` 上面建立東西時，

::

   > (setf x (cons 'a nil))
   (A)

.. figure:: ../images/Figure-3.1.png

圖 3.1 一個元素的列表

產生的列表由一個 Cons 所組成，見圖3.1。這種表達 Cons 的方式叫做箱子表示法 (box notation)，因為每一個 Cons 是用一個箱子表示，內含一個 ``car`` 和 ``cdr`` 的指標。當我們呼叫 ``car`` 與 ``cdr`` 時，我們得到指標指向的地方：

::

   > (car x)
   A
   > (cdr x)
   NIL

當我們創建一個多元素的列表時，我們得到一串 Conses (a chain of conses)：

::

   > (setf y (list 'a 'b 'c))
   (A B C)

產生的結構見圖 3.2。現在當我們想得到這個列表的 ``cdr`` 時，它是一個兩個元素的列表。

.. figure:: ../images/Figure-3.2.png

圖 3.2 三個元素的列表

::

   > (cdr y)
   (B C)

在一個有多個元素的列表中， ``car`` 指標讓你取得元素，而 ``cdr`` 讓你取得列表內其餘的東西。

一個列表可以有任何種類的物件作為元素，包括另一個列表：

::

   > (setf z (list 'a (list 'b 'c) 'd))
   (A (B C) D)

當這種情況發生時，它的結構如圖3.3所示; 第二個 Cons 的 ``car`` 指標也指向一個列表：

::

  > (car (cdr z))
  (B C)

.. figure:: ../images/Figure-3.3.png

圖 3.3 巢狀列表


前兩個我們創建的列表都有三個元素; 只不過 ``z`` 列表的第二個元素也剛好是一個列表。像這樣的列表稱為 *巢狀* 列表，而像 ``y`` 這樣的列表稱之為 *平坦* 列表 ( *flat* list)。

如果參數是一個 Cons 物件，函數 ``consp`` 回傳真。所以我們可以這樣定義 ``listp`` ：

::

  (defun our-listp (x)
  	(or (null x) (consp x)))

因為所有不是 Cons 物件的東西就是一個原子 (atom)，判斷式 ``atom`` 可以這樣定義：

::

   (defun our-atom (x) (not (consp x)))

注意， ``NIL`` 是一個原子，同時也是一個列表。

3.2 等式 (Equality)
=====================

每一次你呼叫 ``cons`` 時， Lisp 會分配一塊新的記憶體給兩個指標。所以如果我們用同樣的參數呼叫 ``cons`` 兩次，我們得到兩個數值看起來一樣，但實際上是兩個不同的物件：

::

   > (eql (cons 'a nil) (cons 'a nil))
   NIL

如果我們也可以詢問兩個列表是否有相同元素，那就很方便了。 Common Lisp 提供了這種目的另一個判斷式： ``equal`` 。而另一方面 ``eql`` 只有在它的參數是相同物件時才回傳真，

::

   > (setf x (cons 'a nil))
   (A)
   > (eql x x)
   T

本質上 ``equal`` 若它的參數列印出的值相同時，回傳真：

::

   > (equal x (cons 'a nil))
   T

這個判斷式對非列表結構的別種物件也有效，但一種僅對列表有效的版本可以這樣定義：

::

   > (defun our-equal (x y)
       (or (eql x y)
           (and (consp x)
                (consp y)
                (our-equal (car x) (car y))
                (our-equal (cdr x) (cdr y)))))

這個定義意味著，如果某個 x 和 y 相等 ( ``eql`` )，那麼他們也相等 ( ``equal`` )。

**勘誤:** 這個版本的 ``our-equal`` 可以用在符號的列表 (list of symbols)，而不是列表 (list)。

3.3 為什麼 Lisp 沒有指標 (Why Lisp Has No Pointers)
=======================================================

一個理解 Lisp 的祕密之一是意識到變數是有值的，就像列表有元素一樣。如同 Conses 物件有指標指向他們的元素，變數有指標指向他們的值。

你可能在別的語言中使用過顯式指標 (explicitly pointer)。在 Lisp ，你永遠不用這麼做，因為語言幫你處理好指標了。我們已經在列表看過這是怎麼達成的。同樣的事情發生在變數身上。舉例來說，假設我們想要把兩個變數設成同樣的列表：

::

   > (setf x '(a b c))
   (A B C)
   > (setf y x)
   (A B C)

.. figure:: ../images/Figure-3.4.png

圖3.4 兩個變數設為相同的列表

當我們把 x 的值賦給 y 時，究竟發生什麼事呢？記憶體中與 x 有關的位置並沒有包含這個列表，而是一個指標指向它。當我們給 y 賦一個相同的值時， Lisp 複製的是指標，而不是列表。（圖 3.4 顯式賦值 x 給 y 後的結果）所以無論何時你把一個變數賦給另一個變數時，兩個變數會有 ``eql`` 的值。

::

   > (eql x y)
   T

Lisp 沒有指標的原因是因為每一個值，其實概念上來說都是一個指標。當你賦一個值給變數或將這個值存在資料結構中，其實被儲存的是指向這個值的指標。當你要取得變數的值，或是存在資料結構中的內容時， Lisp 回傳指向這個值的指標。但這都在檯面下發生。你可以不加思索地把值放在結構裡，或放 "在" 變數裡。

為了效率的原因， Lisp 有時會選擇一個折衷的表示法，而不是指標。舉例來說，因為一個小整數所需的記憶體空間，少於一個指標所需的空間，一個 Lisp 實現可能會直接處理這個小整數，而不是用指標來處理。但基本要點是，程式設計師，預設上，你可以把任何東西放在任何地方。除非你宣告你不願這麼做，不然你能夠在任何的資料結構，存放任何種類的物件，包括結構本身。

3.4 建立列表 (Building Lists)
=================================

.. figure:: ../images/Figure-3.5.png

圖 3.5 複製的結果

函數 ``copy-list`` 接受一個列表，然後返回此列表的副本。新的列表會有同樣的元素，但是裝在新的 Conses 物件裡：

::

   > (setf x '(a b c)
           y (copy-list x))
   (A B C)

圖 3.5 展示出結果的結構; 回傳值像是有著相同乘客的新公車。我們可以把 ``copy-list`` 想成是這麼定義的:

::

   (defun our-copy-list (lst)
     (if (atom lst)
         lst
         (cons (car lst) (our-copy-list (cdr lst)))))

這個定義暗示著 x 與 (copy-list x) 會永遠 ``equal`` ，並永遠不 ``eql`` ，除非 x 是 ``NIL`` 。

最後，函數 ``append`` 回傳任何數目的列表串接 (concatenation)：

::

   > (append '(a b) '(c d) 'e)
   (A B C D E)

通過這麼做，它複製所有的參數，除了最後一個。

3.5 範例：壓縮 (Example: Compression)
============================================

作為一個範例，這節將演示如何實現簡單形式的列表壓縮。這個演算法有一個令人映像深刻的名字， *遊程編碼* (run-length encoding)。

::

   (defun compress (x)
     (if (consp x)
         (compr (car x) 1 (cdr x))
         x))

   (defun compr (elt n lst)
     (if (null lst)
         (list (n-elts elt n))
         (let ((next (car lst)))
           (if (eql next elt)
               (compr elt (+ n 1) (cdr lst))
               (cons (n-elts elt n)
                     (compr next 1 (cdr lst)))))))

   (defun n-elts (elt n)
     (if (> n 1)
         (list n elt)
         elt))

圖 3.6 遊程編碼 (Run-length encoding)：壓縮


在餐廳，這個演算法的工作方式如下。一個女服務生走向有四個客人的桌子。"你們要什麼？" 她問。"我要特餐，" 第一個客人說。
"我也是，" 第二個客人說。"聽起來不錯，" 第三個客人說。每個人看著第四個客人。¨我要一個 "cilantro soufflé，" 他小聲地說。 (譯註：蛋奶酥上面灑香菜跟醬料）

瞬息之間，女服務生就轉身踩著高跟鞋走回櫃檯去了。"三個特餐，" 她大聲對廚師說，"還有一個香菜蛋奶酥。"

圖 3.6 展示了如何實現這個壓縮列表演算法。函數 ``compress`` 接受一個由原子組成的列表，然後回傳一個壓縮的列表：

::

   > (compress '(1 1 1 0 1 0 0 0 0 1))
   ((3 1) 0 1 (4 0) 1)

當相同的元素連續出現好幾次，這個連續出現的序列被一個列表取代，列表指明出現的次數及出現的元素。

主要的工作是由 遞迴的 ``compr`` 所完成。這個函數接受三個參數： ``elt`` ，上一個我們看過的元素; ``n`` ，連續出現的次數， 以及 ``lst`` ，我們還沒檢視過的部分列表。如果沒有東西需要檢視了，我們呼叫 ``n-elts`` 來取得 n elts 的表示法。如果 ``lst`` 的第一個元素還是 ``elt`` ，我們增加出現的次數 ``n`` 並繼續下去。否則我們得到，到目前為止的一個壓縮的列表，然後 ``cons`` 這個列表在 ``compr`` 處理完剩下的列表所回傳的東西之上。

要復原一個壓縮的列表，我們呼叫 ``uncompress`` (圖 3.7)

::

   > (uncompress '((3 1) 0 1 (4 0) 1))
   (1 1 1 0 1 0 0 0 0 1)

::

   (defun uncompress (lst)
     (if (null lst)
         nil
         (let ((elt (car lst))
               (rest (uncompress (cdr lst))))
           (if (consp elt)
               (append (apply #'list-of elt)
                       rest)
               (cons elt rest)))))

   (defun list-of (n elt)
     (if (zerop n)
         nil
         (cons elt (list-of (- n 1) elt))))

圖 3.7 遊程編碼 (Run-length encoding)：解壓縮


這個函數遞迴地遍歷這個壓縮列表，逐字複製原子並呼叫 ``list-of`` ，展開成列表。

::

   > (list-of 3 'ho)
   (HO HO HO)

我們其實不需要自己寫 ``list-of`` 。內建的 ``make-list`` 可以辦到一樣的事情─但它使用了我們還沒介紹到的關鍵字參數 (keyword argument)。

圖 3.6 跟 3.7 這種寫法不是一個有經驗的 Lisp 程式設計師用的寫法。它的效率很差，它沒有盡可能的壓縮，而且它只對由原子組成的列表有效。在幾個章節內，我們會學到解決這些問題的技巧。

::

   載入程式

   在這節的程式是我們第一個實質的程式。
   當我們想要寫超過數行的函數時，
   通常我們會把程式寫在一個檔案，
   然後使用 load 讓 Lisp 讀取函數的定義。
   如果我們把圖 3.6 跟 3.7 的程式，
   存在一個檔案叫做，"compress.lisp" 然後輸入

   (load "compress.lisp")

   到頂層，或多或少的，
   我們會像在直接輸入頂層一樣得到同樣的效果。

   注意：在某些實現中，Lisp 檔案的副檔名會是 ".lsp" 而不是 ".lisp"。

3.6 存取 (Access)
======================

Common Lisp 有額外的存取函數，它們是用 ``car`` 跟 ``cdr`` 所定義的。要找到列表特定位置的元素，我們可以呼叫 ``nth`` ，

::

   > (nth 0 '(a b c))
   A

而要找到第 n 個 cdr ，我們呼叫 ``nthcdr`` ：

::

   > (nthcdr 2 '(a b c))
   (C)

``nth`` 與 ``nthcdr`` 都是零索引的 (zero-indexed); 即元素從 0 開始編號，而不是從 1 開始。在 Common Lisp 裡，無論何時你使用一個數字來參照一個資料結構中的元素時，都是從 0 開始編號的。

兩個函數幾乎做一樣的事; ``nth`` 等同於取 ``nthcdr`` 的 ``car`` 。沒有檢查錯誤的情況下， ``nthcdr`` 可以這麼定義：

::

   (defun our-nthcdr (n lst)
     (if (zerop n)
         lst
         (our-nthcdr (- n 1) (cdr lst))))

函數 ``zerop`` 僅在參數為零時，才回傳真。

函數 ``last`` 回傳列表的最後一個 Cons 物件：

::

   > (last '(a b c))
   (C)

這跟取得最後一個元素不一樣。要取得列表的最後一個元素，你要取得 ``last`` 的 ``car`` 。

Common Lisp 定義了函數 ``first`` 直到 ``tenth`` 可以取得列表對應的元素。這些函數不是 *零索引的* (zero-indexed)：

``(second x)`` 等同於 ``(nth 1 x)`` 。

此外， Common Lisp 定義了像是 ``caddr`` 這樣的函數，它是 cdr 的 cdr 的 car 的縮寫 (car of cdr of cdr)。所有這樣形式的函數 ``cxr`` ，其中 x 是一個字串，最多四個 a 或 d ，在 Common Lisp 裡都被定義好了。使用 ``cadr`` 可能會有例外 (exception)產生，這不是一個好主意，在所有人都可能會讀的程式碼裡來使用這樣的函數。

3.7 映成函數 (Mapping Functions)
============================================

Common Lisp 提供了數個函數來對一個列表的元素做函數呼叫。最常使用的是 ``mapcar`` ，接受一個函數與一個或多個列表，並回傳把函數應用至每個列表的元素的結果，直到有的列表沒有元素為止：

::

   > (mapcar #'(lambda (x) (+ x 10))
             '(1 2 3))
   (11 12 13)

   > (mapcar #'list
             '(a b c)
             '(1 2 3 4))
   ((A 1) (B 2) (C 3))

相關的 ``maplist`` 接受同樣的參數，將列表的漸進的下一個 cdr 傳入函數。

::

   > (maplist #'(lambda (x) x)
              '(a b c))
   ((A B C) (B C) (C))

其它的映成函數，包括 ``mapc`` 我們在 88 頁討論 （譯註: 5.8 節），以及 ``mapcan`` 在 202 頁（譯註: 12.4 節）討論。

3.8 樹 (Trees)
======================

Conses 物件可以想成是二元樹， ``car`` 代表右子樹，而 ``cdr`` 代表左子樹。舉例來說，列表

(a (b c) d) 也是一棵由圖 3.8 所代表的樹。（如果你逆時針旋轉45度，你會發現跟圖 3.3 一模一樣）

.. figure:: ../images/Figure-3.8.png

圖 3.8 二元樹 (Binary Tree)

Common Lisp 有幾個內建的給樹使用的函數。舉例來說， ``copy-tree`` 接受一個樹，並回傳一份副本。它可以這麼定義：

::

   (defun our-copy-tree (tr)
     (if (atom tr)
          tr
          (cons (our-copy-tree (car tr))
                (our-copy-tree (cdr tr)))))

把這跟 36 頁的 ``copy-list`` 比較一下; ``copy-tree`` 複製每一個 Cons 物件的 car 與 cdr，而 ``copy-list`` 僅複製 cdr。

沒有內部節點的二元樹沒有太大的用處。 Common Lisp 包含了操作樹的函數，不只是因為我們需要樹這個結構，而是因為我們需要一種方法，來操作列表及所有內部的列表。舉例來說，假設我們有一個這樣的列表：

::

   (and (integerp x) (zerop (mod x 2)))

而我們想要把各處的 x 都換成 y 。呼叫 ``substitute`` 是不行的，它只能替換序列 (sequence)中的元素：

::

   > (substitute 'x 'y '(and (integerp x) (zerop (mod x 2))))
   (AND (INTEGERP X) (ZEROP (MOD X 2)))

這個呼叫是無效的，因為列表有三個元素，沒有一個元素是 x 。我們在這所需要的是 ``subst`` ，它替換樹中的元素。

::

   > (subst 'y 'x '(and (integerp x) (zerop (mod x 2))))
   (AND (INTEGERP Y) (ZEROP (MOD Y 2)))

如果我們定義一個 ``subst`` 的版本，它看起來跟 ``copy-tree`` 很相似：

::

   > (defun our-subst (new old tree)
       (if (eql tree old)
           new
           (if (atom tree)
               tree
               (cons (our-subst new old (car tree))
                     (our-subst new old (cdr tree))))))

操作樹的函數通常有這種形式，car 與 cdr 同時做遞迴。這種函數被稱之為是 *雙重遞迴* (doubly recursive)。

3.9 理解遞迴 (Understanding Recursion)
============================================

學生在學習遞迴時，有時候是被鼓勵在紙上追蹤 (trace)遞迴程式調用 (invocation)的過程。 （ 288頁（譯註：Appendix A Trace and Backtraces）可以看到一個遞迴函數的追蹤過程。）但這種練習可能會誤導你：一個程式設計師在定義一個遞迴函數時，通常不會明確地去想呼叫函數後，函數調用的順序是什麼。

如果一個人總是需要這樣子思考程式，遞迴會是艱難的、沒有幫助的。遞迴的優點是它精確地讓我們更抽象地來檢視演算法。你不需要考慮真正呼叫函數時所有的調用 (invocation)過程，就可以判斷一個遞迴函數是否是正確的。

要知道一個遞迴函數是否做它該做的事，你只需要問，它包含了所有的情況嗎？舉例來說，下面是一個尋找列表長度的遞迴函數：

::

   > (defun len (lst)
       (if (null lst)
           0
           (+ (len (cdr lst)) 1)))

我們可以藉由檢查兩件事情，來確信這個函數是正確的：

1. 對長度為 0 的列表是有效的。
2. 給定它對於長度為 n 的列表是有效的，它對長度是 n+1 的列表也是有效的。

如果這兩點是成立的，我們知道這個函數對於所有可能的列表都是正確的。

我們的定義顯然地滿足第一點：如果 列表 ( ``lst`` ) 是空的 ( ``nil`` )，函數直接回傳 0。現在假定我們的函數對長度為 n 的列表是有效的。我們給它一個 n+1 長度的列表。這個定義說明了，函數會回傳列表的 cdr 的長度再加上 1。 cdr 是一個長度為 n 的列表。我們經由假定可知它的長度是 n。所以整個列表的長度是 n+1。

我們需要知道的就是這些。理解遞迴的祕密就像是處理括號一樣。你怎麼知道哪個括號對上哪個？你不需要這麼做。你怎麼想像那些調用過程？你不需要這麼做。

更複雜的遞歸函數，可能會有更多的情況需要討論，但是流程是一樣的。舉例來說， 41 頁的 ``our-copy-tree`` ，我們需要討論三個情況： 原子，單一的 Cons 物件， n+1 的 Cons 樹。

第一個情況（長度零的列表）稱之為 *基本情況* ( *base case* )。當一個遞迴函數不像你想的那樣工作時，通常是因為基本情況是錯的。下面這個不正確 ``member`` 定義，是一個常見的錯誤，整個忽略了基本情況：

::

   (defun our-member (obj lst)
     (if (eql (car lst) obj)
         lst
         (our-member obj (cdr lst))))

我們需要初始一個 ``null`` 測試，確保在到達列表底部時，沒有找到目標要停止遞迴。如果我們要找的物件沒有在列表裡，這個版本的 ``member`` 會陷入無窮迴圈。附錄 A 更詳細地檢視了這種問題。

能夠判斷一個遞迴函數是否正確只不過是理解遞迴的上半場，下半場是能夠寫出一個做你想做的事情的遞迴函數。 6.9 節討論了這個問題。

3.10 集合 (Sets)
======================

列表是表示小集合 (small sets)的好方法。列表中的每個元素都代表了一個集合的成員：

::

   > (member 'b '(a b c))
   (B C)

當 ``member`` 要回傳"真"時，與其僅僅回傳 ``t`` ，它回傳由尋找物件所開始的那部分。邏輯上來說，一個 Cons 扮演的角色和 ``t`` 一樣，而經由這麼做，函數回傳了更多資訊。

一般情況下， ``member`` 使用 ``eql`` 來比較物件。你可以使用一種叫做關鍵字參數 (keyword argument)的東西來重寫 (override) 預設的比較方法。多數的 Common Lisp 函數接受一個或多個關鍵字參數。這些關鍵字參數不同的地方是，他們不是把對應的參數放在特定的位置作匹配，而是在函數呼叫中用特殊標籤，稱為關鍵字，來作匹配。一個關鍵字是一個前面有冒號的符號。

有一個 ``member`` 接受的關鍵字參數是 ``:test`` 參數。

如果你在呼叫 ``member`` 時，傳入某個函數作為 ``:test`` 參數，那麼那個函數就會被用來比較是否相等，而不是用 ``eql`` 。所以如果我們想找到一個給定的物件與列表中的成員是否相等 ( ``equal`` )，我們可以：

::

   > (member '(a) '((a) (z)) :test #'equal)
   ((A) (Z))

關鍵字參數總是選擇性添加的。如果你在一個呼叫中包含了任何的關鍵字參數，他們要擺在最後; 如果使用了超過一個的關鍵字參數，擺放的順序無關緊要。

另一個 ``member`` 接受的關鍵字參數是 ``:key`` 參數。藉由提供這個參數，你可以在作比較之前，指定一個函數運用在每一個元素：

::

   > (member 'a '((a b) (c d)) :key #'car)
   ((A B) (C D))

在這個例子裡，我們詢問是否有一個元素的 ``car`` 是 ``a`` 。

如果我們想要使用兩個關鍵字參數，我們可以使用其中一個順序。下面這兩個呼叫是等價的：

::

   > (member 2 '((1) (2)) :key #'car :test #'equal)
   ((2))
   > (member 2 '((1) (2)) :test #'equal :key #'car)
   ((2))

兩者都詢問是否有一個元素的 ``car`` 等於 ( ``equal`` ) 2。

如果我們想要找到一個元素滿足任意的判斷式像是 ─ ``oddp`` ，奇數回傳真─我們可以使用相關的 ``member-if`` ：

::

   > (member-if #'oddp '(2 3 4))
   (3 4)

我們可以想像一個限制性的版本 ``member-if`` 是這樣寫成的：

::

   (defun our-member-if (fn lst)
    (and (consp lst)
         (if (funcall fn (car lst))
             lst
             (our-member-if fn (cdr lst)))))

函數 ``adjoin`` 像是條件式的 ``cons`` (conditional ``cons`` )。它接受一個物件及一個列表，如果物件還不是列表的成員，就在創建物件至列表上。

::

   > (adjoin 'b '(a b c))
   (A B C)
   > (adjoin 'z '(a b c))
   (Z A B C)

通常的情況下它接受與 ``member`` 函數同樣的關鍵字參數。

集合論中的聯集 (union)、交集 (intersection)及補集 (complement)的實現是由函數 ``union`` 、 ``intersection`` 以及 ``set-difference`` 。

這些函數期望兩個 (exactly 2)列表（一樣接受與 ``member`` 函數同樣的關鍵字參數）。

::

   > (union '(a b c) '(c b s))
   (A C B S)
   > (intersection '(a b c) '(b b c))
   (B C)
   > (set-difference '(a b c d e) '(b e))
   (A C D)

因為集合中沒有順序的概念，這些函數不需要保留原本元素在列表被找到的順序。舉例來說，呼叫 ``set-difference`` 也有可能回傳 ``(d c a)`` 。

3.11 序列 (Sequences)
=================================

另一種考慮一個列表的方式是想成一系列有特定順序的物件。在 Common Lisp 裡， *序列* ( *sequences* )包括了列表與向量 (vectors)。本節介紹了一些可以運用在列表上的序列函數。更深入的序列的操作在 4.4 節討論。

函數 ``length`` 回傳序列中元素的數目。

::

   > (length '(a b c))
   3

我們在 page 24 (譯註：2.13節 ``our-length`` )寫過這種函數的一個版本（僅可用於列表）。

要複製序列的一部分，我們使用 ``subseq`` 。第二個（需要的）參數是第一個開始引用進來的元素位置，第三個（選擇性的）參數是第一個不引用進來的元素位置。

::

   > (subseq '(a b c d) 1 2)
   (B)
   >(subseq '(a b c d) 1)
   (B C D)

如果省略了第三個參數，子序列會從第二個參數給定的位置引用到序列尾端。

函數 ``reverse`` 回傳與其參數相同元素的一個序列，但順序顛倒。

::

   > (reverse '(a b c))
   (C B A)

一個迴文 (palindrome) 是一個正讀反讀都一樣的序列 ─ 舉例來說， ``(a b b a)`` 。如果一個迴文有偶數個元素，那麼後半段會是前半段的鏡射 (mirror)。使用 ``length`` 、 ``subseq`` 以及 ``reverse`` ，我們可以定義一個函數

::

   (defun mirror? (s)
     (let ((len (length s)))
       (and (evenp len)
            (let ((mid (/ len 2)))
              (equal (subseq s 0 mid)
                     (reverse (subseq s mid)))))))

來檢測是否是迴文：

::

   > (mirror? '(a b b a))
   T

Common Lisp 有一個內建的排序函數叫做 ``sort`` 。它接受一個序列及一個比較兩個參數的函數，回傳一個有同樣元素的序列，根據比較函數來排序：

::

   > (sort '(0 2 1 3 8) #'>)
   (8 3 2 1 0)

你要小心使用 ``sort`` ，因為它是 *破壞性的* ( *destructive* )。考慮到效率的因素， ``sort`` 被允許修改傳入的序列。所以如果你不想你本來的序列被改動，傳入一個副本。

使用 ``sort`` 及 ``nth`` ，我們可以寫一個函數，接受一個整數 ``n`` ，回傳列表中第 n 大的元素：

::

   (defun nthmost (n lst)
     (nth (- n 1)
          (sort (copy-list lst) #'>)))

我們把整數減一因為 ``nth`` 是零索引的，但如果 ``nthmost`` 是這樣的話，會變得很不直觀。

::

  (nthmost 2 '(0 2 1 3 8))

多努力一點，我們能寫出這個函數的一個更有效率的版本。

函數 ``every`` 和 ``some`` 接受一個判斷式及一個或多個序列。當我們僅輸入一個序列時，它們測試序列元素是否滿足判斷式：

::

   > (every #'oddp '(1 3 5))
   T
   > (some #'evenp '(1 2 3))
   T

如果它們輸入多於一個序列時，判斷式必須接受與序列一樣多的元素作為參數，而參數從所有序列中一次提取一個：

::

   > (every #'> '(1 3 5) '(0 2 4))
   T

如果序列有不同的長度，最短的那個序列，決定需要測試的次數。

3.12 堆疊 (Stacks)
=================================

用 Cons 物件來表示的列表，很自然地我們可以拿來實現下推堆疊 (pushdown stack)。這太常見了，以致於 Common Lisp 提供了兩個巨集給堆疊使用： ``(push x y)`` 把 x 放入列表 y 的前端。而 ``(pop x)`` 則是將列表 x 的第一個元素移除並回傳這個元素。

兩個函數都由 ``setf`` 來定義的。如果參數是常數或變數，很簡單就可以翻譯出函數呼叫。表達式

``(push obj lst)``

等同於

``(setf lst (cons obj lst))``

.. figure:: ../images/Figure-3.9.png

圖 3.9 push 及 pop 的效果

以及表達式

``(pop lst)``

等同於

::

   (let ((x (car lst)))
     (setf lst (cdr lst))
     x)

所以，舉例來說：

::

   > (setf x '(b))
   (B)
   > (push 'a x)
   (A B)
   > x
   (A B)
   > (setf y x)
   (A B)
   > (pop x)
   (A)
   > x
   (B)
   > y
   (A B)

以上全都遵循上述由 ``setf`` 所給出的相等式。圖 3.9 展示了這些表達式被求值後的結構。

你可以使用 ``push`` 來定義一個給列表使用的互動版 ``reverse`` 。

::

   (defun our-reverse (lst)
     (let ((acc nil))
       (dolist (elt lst)
         (push elt acc))
       acc))

在這個版本，我們從一個空列表開始，然後把 lst 的每一個元素放入空表裡。等我們完成時，lst 最後一個元素會在最前端。

``pushnew`` 巨集是 ``push`` 的變種，使用了 ``adjoin`` 而不是 ``cons`` ：

::

   > (let ((x '(a b)))
       (pushnew 'c x)
       (pushnew 'a x)
       x)
  (C A B)

在這裡， c 被放入列表，但是 a 沒有，因為它已經是列表的一個成員了。

3.13 點狀列表 (Dotted Lists)
=================================

由呼叫 ``list`` 所創建的列表，這種列表精確地說稱之為 常規列表( *proper* list )。一個常規列表可以是 ``nil`` 或一個 cdr 是常規列表的 Cons 物件。也就是說，我們可以定義一個只對常規列表回傳真的判斷式： [3]_

::

   (defun proper-list? (x)
     (or (null x)
         (and (consp x)
              (proper-list? (cdr x)))))

至目前為止，我們創建的列表都是常規列表。

然而， ``cons`` 不僅是創建列表。無論何時你需要一個具有兩個變數 (field)的列表，你可以使用一個 Cons 物件。你能夠使用 ``car`` 來參照第一個變數，用 ``cdr`` 來參照第二個變數。

::

   > (setf pair (cons 'a 'b))
   (A . B)

因為這個 Cons 物件不是一個常規列表，它用點狀表示法來顯示。在點狀表示法， 每個 Cons 物件 的 ``car`` 與 ``cdr`` 由一個句點隔開來表示。這個 Cons 物件的結構展示在圖 3.10 。

.. figure:: ../images/Figure-3.10.png

圖 3.10 一個成對的 Cons 物件 (A cons used as a pair)

一個非常規列表的 Cons 物件稱之為點狀列表 (dotted list)。這不是個好名字，因為非常規列表的 Cons 物件通常不是用來表示列表： ``(a . b)`` 只是一個有兩部分的資料結構。

你也可以用點狀表示法表示常規列表，但當 Lisp 顯示一個常規列表時，它會使用普通的列表表示法：

::

   > '(a . (b . (c . nil)))
   (A B C)

順道一提，注意列表由點狀表示法與圖 3.2 箱子表示法的關聯性。

還有一個過渡形式 (intermediate form)的表示法，介於列表表示法及純點狀表示法之間，對於 ``cdr`` 是 Cons 物件的點狀列表：

::

   > (cons 'a (cons 'b (cons 'c 'd)))
   (A B C . D)

.. figure:: ../images/Figure-3.11.png

圖 3.11 一個點狀列表 (A dotted list)

這樣的 Cons 物件看起來像常規列表，除了最後一個 cdr 前面有一個句點。這個列表的結構展示在圖 3.11 ; 注意它跟圖 3.2 是多麼的相似。

所以實際上你可以這麼表示列表 ``(a b)`` ，

::

   (a . (b . nil))
   (a . (b))
   (a b .nil)
   (a b)

雖然 Lisp 總是使用後面的形式，來顯示這個列表。

3.14 關聯列表 (Assoc-lists)
===================================

用 Cons 物件來表示映射 (mapping)也是很自然的。一個由 Cons 物件組成的列表稱之為 *關聯列表* ( *assoc-list* or *alist* )。這樣的列表可以表示一個翻譯的集合，舉例來說：

::

   > (setf trans '((+ . "add") (- . "subtract")))
   ((+ . "add") (- . "subtract"))

關聯列表很慢，但是在初期的程式中很方便。 Common Lisp 有一個內建的函數， ``assoc`` 用來取出在關聯列表中，與給定的鍵值有關聯的 Cons 對：

::

   > (assoc '+ trans)
   (+ . "add")
   > (assoc '* trans)
   NIL

如果 ``assoc`` 沒有找到要找的東西時，回傳 nil 。

我們可以定義一個受限版本的 ``assoc`` ：

::

   (defun our-assoc (key alist)
     (and (consp alist)
          (let ((pair (car alist)))
          (if (eql key (car pair))
              pair
              (our-assoc key (cdr alist))))))

和 ``member`` 一樣，實際上的 ``assoc`` 接受關鍵字參數，包括 ``:test`` 和 ``:key`` 。Common Lisp 也定義了一個 ``assoc-if`` 之於 ``assoc`` ，如同 ``member-if`` 之於 ``member`` 一樣。

3.15 範例：最短路徑 (Example: Shortest Path)
==================================================

圖 3.12 包含一個搜索網路中最短路徑的程式。函數 ``shortest-path`` 接受一個起始節點，目的節點以及一個網路，並回傳最短路徑，如果有的話。

在這個範例中，節點用符號表示，而網路用含以下元素形式的關聯列表 (assoc-lists)來表示：

*(node . neighbors)*

所以由圖 3.13 展示的最小網路 (minimal network)可以這樣來表示：

``(setf min '((a b c) (b c) (c d)))``

::

   (defun shortest-path (start end net)
     (bfs end (list (list start)) net))

   (defun bfs (end queue net)
     (if (null queue)
         nil
         (let ((path (car queue)))
           (let ((node (car path)))
             (if (eql node end)
                 (reverse path)
                 (bfs end
                      (append (cdr queue)
                              (new-paths path node net))
                      net))))))

   (defun new-paths (path node net)
     (mapcar #'(lambda (n)
                 (cons n path))
             (cdr (assoc node net))))

圖 3.12 廣度優先搜索 (breadth-first search)

.. figure:: ../images/Figure-3.13.png

圖 3.13 最小網路

要找到從節點 a 可以到達的節點，我們可以：

::

   > (cdr (assoc 'a min))
   (B C)

圖 3.12 程式的工作方式為使用廣度優先的方式搜索網路。要使用廣度優先搜索，你需要維護一個含有未探索節點的佇列。每一次你到達一個節點，檢查這個節點是否是你要的。如果不是，你把這個節點的子節點加入佇列的尾端，並從佇列起始選一個節點，從這繼續搜索。藉由總是把較深的節點放在佇列尾端，我們確保網路一次被搜索一層。

圖 3.12 中的程式碼較不複雜地表示這個概念。我們不僅想要找到節點，還想保有我們怎麼到那的紀錄。所以與其維護一個具有節點的佇列，我們維護一個已知路徑的佇列，每個已知路徑都是一列節點。當我們從佇列取出一個元素繼續搜索時，它是一個含有佇列前端節點的列表，而不只是一個節點而已。

函數 ``bfs`` 負責搜索。起初佇列只有一個元素，一個表示從起點開始的路徑。所以 ``shortest-path`` 呼叫 ``bfs`` ，並傳入 ``(list (list start))`` 作為初始佇列。

``bfs`` 函數第一件要考慮的事是，是否還有節點需要探索。如果佇列為空， ``bfs`` 回傳 nil 指出沒有找到路徑。如果還有節點需要搜索， ``bfs`` 檢視佇列前端的節點。如果節點的 ``car`` 部分是我們要找的節點，我們回傳這個找到的路徑，並且為了可讀性的原因我們反轉它。如果我們沒有找到我們要找的節點，它有可能在現在節點之後，所以我們把它的子節點 （或是每一個子路徑）加入佇列尾端。然後我們遞迴地呼叫 ``bfs`` 來繼續搜尋剩下的佇列。

因為 ``bfs`` 廣度優先地搜索，第一個找到的路徑會是最短的，或是最短之一：

::

   > (shortest-path 'a 'd min)
   (A C D)

這是佇列在我們連續呼叫 ``bfs`` 看起來的樣子：

::

   ((A))
   ((B A) (C A))
   ((C A) (C B A))
   ((C B A) (D C A))
   ((D C A) (D C B A))

在佇列中的第二個元素變成下一個佇列的第一個元素。佇列的第一個元素變成下一個佇列尾端元素的 ``cdr`` 部分。

在圖 3.12 的程式碼不是搜索一個網路最快的方法，但它給出了列表具有多功能的概念。在這個簡單的程式中，我們用三種不同的方式使用了列表：我們使用一個符號的列表來表示路徑，一個路徑的列表來表示在廣度優先搜索中的佇列 [4]_ ，以及一個關聯列表來表示網路本身。

3.16 垃圾 (Garbages)
=========================

有很多原因可以使列表變慢。列表提供了循序存取而不是隨機存取，所以列表取出一個指定的元素比陣列慢，同樣的原因，錄音帶取出某些東西比在光碟上慢。電腦內部裡， Cons 物件傾向於用指標表示，所以走訪一個列表意味著走訪一系列的指標，而不是簡單地像陣列一樣增加索引值。但這兩個所花的代價與配置及回收 Cons 核 (cons cells)比起來小多了。

*自動記憶體管理* ( *Automatic memory management* )是 Lisp 最有價值的特色之一。 Lisp 系統維護著一段記憶體稱之為堆積 ( *Heap* )。系統持續追蹤堆積當中沒有使用的記憶體，把這些記憶體發放給新產生的物件。 舉例來說，函數 ``cons`` ，回傳一個新配置的 Cons 物件。從堆積中配置記憶體有時候通稱為 *consing* 。

如果記憶體永遠沒有釋放， Lisp 會因為創建新物件把記憶體用完，而必須要關閉。所以系統必須週期性地通過搜索堆積 (heap)，尋找不需要再使用的記憶體。不需要再使用的記憶體稱之為垃圾 ( *garbage* )，而清除垃圾的動作稱為垃圾回收 (*garbage collection* 或 GC)。

垃圾是從哪來的？讓我們來創造一些垃圾：

::

   > (setf lst (list 'a 'b 'c))
   (A B C)
   > (setf lst nil)
   NIL

一開始我們呼叫 ``list`` ， ``list`` 呼叫 ``cons`` ，在堆積上配置了一個新的 Cons 物件。在這個情況我們創出三個 Cons 物件。之後當我們把 ``lst`` 設為 ``nil`` ，我們沒有任何方法可以再存取 ``lst`` ，列表 ``(a b c)`` 。 [5]_

因為我們沒有任何方法再存取列表，它也有可能是不存在的。我們不再有任何方式可以存取的物件叫做垃圾。系統可以安全地重新使用這三個 cons 核。

這種管理記憶體的方法，給程式設計師帶來極大的便利性。你不用顯式地配置 (allocate)或釋放 (dellocate)記憶體。這也表示了你不需要處理因為這麼做而可能產生的臭蟲。記憶體洩漏 (Memory leaks)以及迷途指標 (dangling pointer)在 Lisp 中根本不可能發生。

但是像任何的科技進步，如果你不小心的話，自動記憶體管理也有可能對你不利。使用及回收堆積所帶來的代價有時可以看做 ``cons`` 的代價。這是有理的，除非一個程式從來不丟棄任何東西，不然所有的 Cons 物件終究要變成垃圾。Consing 的問題是，配置空間與清除記憶體，與程式的常規運作比起來花費昂貴。近期的研究提出了大幅改善記憶體回收的演算法，但是 consing 總是需要代價的，在某些現有的 Lisp 系統中，代價是昂貴的。

除非你很小心，不然很容易寫出過度顯式創建 cons 物件的程式。舉例來說， ``remove`` 需要複製所有的 ``cons`` 核，直到最後一個元素從列表中移除。你可以藉由使用破壞性的函數避免某些 consing，它試著去重用列表的結構作為參數傳給它們。破壞性函數會在 12.4 節討論。

當寫出 ``cons`` 很多的程式是如此簡單時，我們還是可以寫出不使用 ``cons`` 的程式。典型的方法會是寫出一個純函數風格，使用很多列表的第一版程式。當程式進化時，你可以在程式碼的關鍵部份使用破壞性函數以及/或別種資料結構。但這很難給出通用的建議，因為有些 Lisp 實現，記憶體管理處理得相當好，以致於使用 cons 有時比不使用 cons 還快。這整個議題在 13.4 做更進一步的細部討論。

無論如何 Consing 在原型跟實驗時是好的。而且如果你利用了列表給你帶來的靈活性，你有較高的可能寫出後期可存活下來的程式。

Chapter 3 總結 (Summary)
============================

1. 一個 cons 是一個含兩部分的資料結構。列表用鏈結在一起的 cons 組成。
2. 判斷式 ``equal`` 比 ``eql`` 來得不嚴謹。基本上，如果傳入參數印出來的值一樣時，回傳真。
3. 所有 Lisp 物件表現得像指標。你永遠不需要顯式操作指標。
4. 你可以使用 ``copy-list`` 複製列表，並使用 ``append`` 來連接它們的元素。
5. 遊程編碼是一個餐廳中使用的簡單壓縮演算法。
6. Common Lisp 有由 ``car`` 與 ``cdr`` 定義的多種存取函數。
7. 映成函數應用函數至逐項的元素，或逐項的列表尾端。
8. 巢狀列表的操作有時被考慮為樹的操作。
9. 要判斷一個遞迴函數是否正確，你只需要考慮是否包含了所有情況。
10. 列表可以用集合表示。數個內建函數把列表當作集合。
11. 關鍵字參數是選擇性的，並不是由位置所識別，是用符號前面的特殊標籤來識別。
12. 列表是序列的子型態。 Common Lisp 有大量的序列函數。
13. 一個不是常規列表的 cons 稱之為點狀列表。
14. 用 cons 物件作為元素的列表，可以拿來表示對應關係。這樣的列表稱為關聯列表 (assoc-lists)。
15. 自動記憶體管理拯救你處理記憶體配置的煩惱，但製造過多的垃圾會程式變慢。

Chapter 3 練習 (Exercises)
==================================

1. 用箱子表示法表示以下列表：

::

  (a) (a b (c d))
  (b) (a (b (c (d))))
  (c) (((a b) c) d)
  (d) (a (b . c) d)

2. 寫一個保留原本列表中元素順序的 ``union`` 版本：

::

   > (new-union '(a b c) '(b a d))
   (A B C D)

3. 定義一個函數，接受一個列表並回傳一個列表，指出相等元素出現的次數，並由最常見至最少見的排序：

::

   > (occurrences '(a b a d a c d c a))
   ((A . 4) (C . 2) (D . 2) (B . 1))

4. 為什麼 ``(member '(a) '((a) (b)))`` 回傳 nil？

5. 假設函數 ``pos+`` 接受一個列表並回傳把每個元素加上自己的位置的列表：

::

   > (pos+ '(7 5 1 4))
   (7 6 3 7)

使用 (a) 遞迴 (b) 迭代 (c) ``mapcar`` 來定義這個函數。

6. 經過好幾年的審議，政府委員會決定列表應該由 ``cdr`` 指向第一個元素，而 ``car`` 指向剩下的列表。定義符合政府版本的以下函數：

::

  (a) cons
  (b) list
  (c) length (for lists)
  (d) member (for lists; no keywords)

**勘誤:** 要解決 3.6 (b)，你需要使用到 6.3 節的參數 ``&rest`` 。

7. 修改圖 3.6 的程式，使它使用更少 cons 核。（提示：使用點狀列表）

8. 定義一個函數，接受一個列表並用點狀表示法印出：

::

   > (showdots '(a b c))
   (A . (B . (C . NIL)))
   NIL

9. 寫一個程式來找到 3.15 節裡表示的網路中，最長有限的路徑 (不重複）。網路可能包含循環。

.. rubric:: 腳註

.. [3] 這個敘述有點誤導，因為只要是對任何東西都不回傳 nil 的函數，都不是常規列表。如果給定一個 循環 cdr 列表 (cdr-circular list)，它會無法終止。循環列表在 12.7 節 討論。
.. [4] 12.3小節會展示更有效率的佇列實現方式。
.. [5] 事實上，我們有一種方式來存取列表。全域變數 ``*`` , ``**`` , 以及 ``***`` 總是設定為最後三個頂層所回傳的值。這些變數在除錯的時候很有用。
